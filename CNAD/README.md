## Application Delivery Fundamentals

Imagine you work for a software company that provides a popular mobile banking app. Now your team has been working hard on a new feature that allows users to transfer money between accounts with just a few taps on their phone. This feature is critical for staying competitive in the market. But in the past, getting new features like this to users has been a slow and error-prone process due to the following reasons. Before, releasing new features involved manually building and testing the code, which was a time-consuming process that often led to delays in delivery. Even after testing, there was always a risk that bugs would be introduced during deployment, causing further delays and frustrating user experiences. Now the whole process was fraught with long lead times and risks. To overcome this, the team has set up a CI/CD process that automates the entire process of building, testing, and deploying the new feature. With continuous integration, or CI, any code changes are automatically built, tested, and containerized, so catching bugs early in the development process. This means that issues are addressed early, which saves time and prevents the introduction of bugs in later stages. With CD, the deployment of the new feature is automated by pushing the code to a production Kubernetes cluster. With a push-based model, making the process faster and less prone to errors caused by manual deployments. This results in faster deliveries of new features to users, which is critical for staying competitive in the market. Using GitOps practices, you can manage your infrastructure and deployment process as code. This ensures that changes to your infrastructure are tracked and version-controlled, reducing the risk of errors caused by manual deployments. With GitOps, you can also easily roll back changes if something goes wrong, which minimizes the risk of downtime and other issues. The development process was running smoothly until team members began manually making changes to infrastructure and application resources using the command-line interface. This led to potential issues such as configuration drift and manual errors that could cause the system to become unstable or even fail completely. It's important to remember that cloud computing disasters can happen at any time and take many forms, from natural disasters to technical failures such as power outages or network issues to human errors like unauthorized modifications or misconfigurations. In the event of a disaster, the team must have a disaster recovery plan in place to quickly and efficiently recover both the infrastructure and the application. However, the team's manual changes to the infrastructure and application resources using the command-line interface or CLI could create significant challenges in this scenario. Since these changes are not part of the Git repository, it would be difficult to reference them and restore the infrastructure to a desired state and stable configuration. Once the infrastructure and application are back, the team has to go through a process to figure out what changes were done manually and repeat them to get the desired state. This process can be time-consuming and prone to errors, which could further delay the recovery of the system. However, implementing a GitOps approach can greatly simplify this process. By using Git as the single source of truth for both infrastructure and application resources, the team can easily track any changes made to the system and roll them back if necessary. This ensures that the system can be restored to a known state and stable configuration quickly and efficiently, minimizing the risk of further issues. Well, that's it for this video. I'll see you in the next one. 

## What is GitOps?

Let's say that you and your team are responsible for managing a Kubernetes environment for a popular e-commerce website. The website relies on several Kubernetes objects to run smoothly, including Deployments, Services, and ConfigMaps. One day, a team member decides to update the config map that stores the website's branding colors to reflect a new marketing campaign. The team member makes the change directly in the live Kubernetes environment without notifying other team members. Meanwhile, another team member decides to update the Deployment object for the website's checkout service to use a new version of the software. As it turns out, both team members made changes that conflicted with each other. The branding colors used in the checkout process were no longer consistent with the website's overall color scheme, and the updated checkout service did not work correctly with the older branding colors. The resulting issues caused frustration for customers and extra work for the team members who had to spend time debugging and resolving the issues. This is where GitOps comes in. With GitOps, team members make changes to Kubernetes objects by committing changes to a Git repository. When a change is committed, a GitOps operator or tool like Flux or Argo CD automatically pulls the changes from the Git repository and deploys the infrastructure changes to the live environment. In this scenario, the team member who wanted to update the branding colors would create a code change that updated the config map in the Git repository. and submits a pull request to the Git repository for review. Other team members are notified of the PR and can review the proposed changes before approving the merge. When the change is approved, the GitOps operator or tool will pull the changes from Git and deploy the changes to the Kubernetes cluster. Meanwhile, the other team member changes the checkout service version and creates a code change to update the Deployment object. The team member submits a PR to the Git repository for review. The team also becomes aware that the branding colors had been changed in the previous commit. They decide to delay the merge of the latest PR to avoid any possible conflicts. The team understands that merging the new PR could result in inconsistencies in site colors and cause issues for customers. So they decide to wait until the marketing campaign is over to merge the PR, ensuring that the website remains consistent and without any potential issues. So what exactly is GitOps? GitOps can be understood as using Git repositories as a centralized and reliable source of truth for delivering infrastructure as code. So this approach ensures that all changes to the infrastructure are tracked and versioned, making it easier to identify any issues that arise and providing a comprehensive record of all changes made to the system. GitOps ensures that developers are alerted whenever there is any divergence between what is in Git and what is running in a cluster. In such cases, Kubernetes reconcilers are automatically triggered to either update or roll back the cluster, depending on the nature of the discrepancy. By leveraging the power of Git, GitOps makes it possible to manage and deliver infrastructure changes with greater efficiency and accuracy. So GitOps tools and projects. GitOps has paved the way for a new generation of continuous delivery tools that integrate with Git workflows. Three such tools are Flux, Argo, and Jenkins X. Flux, also known as Flux CD, is a Kubernetes-native application that syncs Kubernetes state with config files in a Git repository. It was developed by Weaveworks and is now a graduated CNCF project. Flux watches a Git repo for changes using a pull-based model and periodically syncs any changes with the live Kubernetes environment, and is easy to use and entirely focused on Continuous Delivery to the Kubernetes cluster. However, Flux can only watch one Git repo and can deploy to only one Kubernetes cluster and namespace, which limits its configurability. Argo, also known as Argo CD, is similar to Flux in that it's a declarative GitOps tool designed for Kubernetes. It was originally developed at Intuit and is currently a graduated CloudNative project. Like Flux, Argo is installed as a Kubernetes native app, uses a pull-based model, and focuses on Continuous Delivery. However, a single Argo installation can monitor multiple Git repos and deploy to multiple Kubernetes namespaces, which makes it more flexible than Flux. Jenkins X is a Kubernetes-focused GitOps tool that covers the entire CI/CD process. It's a collection of other open-source tools packaged and relatively simple to deploy, but it's more complex than Argo and Flux as of now. 

## GitOps Principles

Whenever a new technology is introduced, there is often much debate around how it should be governed and what core principles should guide its use. A governing body can help set the standard for the technology and ensure that it is developed and used appropriately. For example, Kubernetes, which is a popular container orchestration system, has the CloudNative Computing Foundation CNCF as its governing body. So the CNCF provides a neutral home for the project ensuring that it remains vendor neutral and community driven. So this is particularly important for new technologies like GitOps as well, which is still a relatively new approach to software delivery and deployment. To ensure clarity and consistency in GitOps practices, it is essential to establish a governing body. The CloudNative Computing Foundation or CNCF has taken the lead in this regard, creating the GitOps working group to oversee the progress of GitOps in a vendor neutral manner. The working group operates under the CNCF App Delivery SIG, which aims to define a vendor neutral meaning of GitOps. The ultimate goal is to create a common language and understanding of GitOps that can be used by everyone in the community. The GitOps working group has started the OpenGitOps project to bring together experts and stakeholders in the GitOps community to define and standardize best practices for GitOps. This project is a vital step towards establishing a foundation for collaboration and interoperability between the open source community, vendors and end user organizations. So after talking and discussing a lot, the OpenGitOps project came up with four simple rules that perfectly summarize GitOps. Number one, declarative. The entire system has to be described declaratively. In Kubernetes, we describe the desired state of our Kubernetes cluster resources using a declarative approach where we define the end state we want to achieve rather than the steps to get there. For example, instead of manually installing and configuring an application, we use a YAML file to specify the desired state of the application. This YAML file might include information about the container image, number of replicas, service type, and any additional configuration settings. Number two, versioned and immutable. The canonical desired system state is versioned in Git. Once we have defined the desired state of our application in the YAML file, we commit it to Git to version control it. Now, this allows us to track changes to the file over time and to revert to previous versions if necessary. And in addition, once the YAML file has been applied to the Kubernetes cluster, it becomes immutable. We do not make any changes to it directly, but instead we create a new version of the file to make updates. Number three, pulled automatically. Approved changes are automatically applied to the system. To deploy our application, we use GitOps tools or agents like Flux or Argo CD to automate the process. And when we push the YAML file to Git, the GitOps tools detect the change with a pull-based model and automatically applies it to the Kubernetes cluster. This automation eliminates the need for manual intervention, making the process faster, more reliable, and less prone to errors. And number four, continuously reconcile. Software agents to ensure correctness and alert on divergence. So once our application is up and running, we want to make sure that it remains in the desired state defined in the YAML file. To achieve this, we use a GitOps tool that continuously monitors the Kubernetes cluster and compares its actual state to the desired state in the YAML file in Git. If there is any divergence between the two, the GitOps tool takes corrective action to bring the cluster back to the desired state. For example, if the number of replicas has been manually increased, the GitOps tool will detect the change and automatically reduce the number of replicas to match the desired state. This continuous reconciliation process ensures that our application remains in a consistent and reliable state at all times. 

## Push vs Pull-based Deployments

Deployment is the process of releasing a new version of an application or software to its users. It involves a series of steps, such as building the application, testing it, and deploying it to production. There are two approaches to the deployment process, pull-based and push-based. Let's look at push-based first. In the push approach to deployment, an external system, such as a continuous delivery pipeline, triggers deployments to the Kubernetes cluster after a successful commit to a Git repository or a previous CI pipeline. This external system or CI pipeline has direct read-write access to the cluster, allowing it to push the changes to the production environment. If you choose to use a push-based deployment approach to a Kubernetes cluster, you will need to expose the cluster credentials outside the cluster and store them in the CI system. This is because the external system, such as the CI/CD pipeline, needs direct access to the cluster to push the changes to the production environment. However, exposing the cluster credentials outside the cluster can pose security risks. It's important to follow best practices for securing these credentials, such as using encryption and access controls to limit who can access them. Additionally, it's recommended to rotate the credentials frequently to reduce the risk of compromise. The next one we're going to talk about is pull-based. The pull approach to deployment is based on the concept that all changes are applied from inside the Kubernetes cluster. This is achieved through the use of an operator that is deployed within the cluster, which regularly scans the associated Git repositories and Docker registries for changes. If a change is detected, the operator updates the cluster state accordingly. One of the main benefits of the pull approach is its inherent security. Since no external client has admin-level access to the cluster, the risk of unauthorized access or malicious attacks is reduced. Instead, all changes are made from within the cluster, which limits the exposure of sensitive credentials and reduces the attack surface. 

## CI/CD with GitOps

GitOps has emerged as a popular methodology for managing Kubernetes infrastructure and applications using Git as a single source of truth. It emphasizes declarative configuration and automated delivery, enabling teams to achieve rapid, predictable, and safe deployments. In GitOps, we use two Git repositories, one for the application code, resources, configuration data, images, and the other for Kubernetes manifests. The Kubernetes manifests repository contains YAML files that describe the desired state of the cluster. It includes Deployment, Service, Ingress, ConfigMap, Secret, and other Kubernetes resources. To implement GitOps, we use an operator like ArgoCD that runs inside the Kubernetes cluster. The ArgoCD operator continuously monitors the Kubernetes manifests repository for changes and reconciles the desired state with the actual state of the cluster. It deploys updates and deletes resources as necessary to achieve the desired state. Let's say a developer commits new changes to the application code repository. To deploy these changes, we use a CI pipeline that consists of unit tests, building artifacts, and creating a Docker image. The CI pipeline then pushes the newly built image to the container registry. Once the new image is available in the container registry, we need to update the Kubernetes manifests repository with a new image version. And this can be done by modifying the YAML files that reference the image and committing the changes to the repository. Next, we raise a pull request to the Kubernetes manifests repository that includes the changes we made. The PR is reviewed and approved by the project manager or architect before merging it to the master branch. And once the PR is merged, the changes are available in the Kubernetes repository. ArgoCD detects the changes made in the Kubernetes manifests repository and syncs the cluster with the desired state. It deploys the updated version of the application automatically, ensuring that the changes are propagated across the cluster in a safe and controlled manner. In addition to automating deployments, GitOps with ArgoCD also provides a reliable rollback mechanism in case of any issues or failures. With ArgoCD, you can execute commands like argocd app history and argocd app rollback to roll back to the previously stable version. In our forthcoming demonstrations, we'll be exploring how to implement this type of pipeline utilizing Git, ArgoCD, and Kubernetes. Although we won't be delving too deeply into the CI aspect, we'll primarily concentrate on the automated deployment or CD aspect with ArgoCD throughout this course. 
